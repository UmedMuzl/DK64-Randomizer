{% from 'macros.html' import toggle_input %}
{% from 'dropdown_multiselector.html' import dropdown_multiselector %}
<div class="container" style="margin-top: 20px;">
    <div class="row">
        <div class="col border panel">
            <h2 class="title">ITEM RANDOMIZER</h2>
            <div class="flex-container">
                <div class="text-start">
                    <p>
                        Shuffles <span class="ir-hint items">items</span><span class="hide-if-ir-decouple decouple-hide"> with <span class="ir-hint checks">checks</span></span> into pools.
                        Drag and drop items <span class="hide-if-ir-decouple">and checks </span>into various pools to determine where items can be placed.
                    </p>
                    <h5>Rules</h5>
                    <ul>
                        <li id="rule-item-shuffle" class="hide-if-ir-decouple decouple-hide">If an item or check remains unshuffled, it's corresponding item/check has to also remain unshuffled.</li>
                        <li id="rule-item-count">Check count must not be lower than item count.</li>
                    </ul>
                </div>
            </div>
            <div class="flex-container">
                <div style="width:50%">
                    <div class="mx-auto" style="width: fit-content">
                        {{ toggle_input("decouple_item_rando", "Decouple Items from Checks", "Enabling this setting decouples items from their checks, resulting in greater control over the pools.") }}
                    </div>
                </div>
                <div style="width:50%">
                    <div class="mx-auto" style="width: fit-content">
                        <div class="item-select">
                            <button
                                class="btn btn-secondary btn-custom-large"
                                type="button"
                                href="#"
                                id="starting_moves_modal"
                                display_name="Customize Starting Moves"
                                data-bs-toggle="modal"
                                data-bs-target="#starting_moves_Modal"
                                data-toggle="tooltip"
                                title="Customize your starting moves. Start with more items, fewer items, certain items, and more.">
                                Customize Starting Moves
                                <span id="shared_shop_warning" data-toggle="tooltip" title="When all moves are purchased in shops, you are extremely likely to run into fill problems if you do not start with enough shared moves! Seeds that do generate will have fill biases - consider starting with training moves.">
                                    <svg xmlns="http://www.w3.org/2000/svg" data-name="Layer 1" viewBox="0 0 18 18" class="warning-icon" style="overflow: visible; margin-bottom: 7px;" stroke="#ffff00" fill="#ffff00">
                                        <path d="M14.876,2.672a3.309,3.309,0,0,0-5.752,0L.414,18.19a3.178,3.178,0,0,0,.029,3.189A3.264,3.264,0,0,0,3.29,23H20.71a3.264,3.264,0,0,0,2.847-1.621,3.178,3.178,0,0,0,.029-3.189ZM12,19a1,1,0,1,1,1-1A1,1,0,0,1,12,19Zm1-5a1,1,0,0,1-2,0V8a1,1,0,0,1,2,0Z"/>
                                    </svg>
                                </span>
                            </button>
                        </div>
                    </div>
                </div>
                <div style="width:50%">
                    <div class="mx-auto" style="width: fit-content">
                        {{ dropdown_multiselector(item_filler, "filler_items", "Filler Items", "Defines what item types can be placed into the world after all mandatory items have been placed.", "0") }}
                    </div>
                </div>
                <div style="width:50%">
                    <div class="mx-auto" style="width: fit-content">
                        {% include "complex-options/ice-trap.html" %}
                    </div>
                </div>
                <div style="width:50%">
                    <div class="mx-auto" style="width: fit-content">
                        {% include "complex-options/item-totals.html" %}
                    </div>
                </div>
                <div style="width:50%">
                    <div class="mx-auto" style="width: fit-content">
                        <div>
                            <p class="select-title">Max Snide Reward Limit</p>
                            <input name="most_snide_rewards"
                                    id="most_snide_rewards"
                                    type="number"
                                    display_name="Max Snide Reward Limit"
                                    class="form-control me-2"
                                    aria-label="Max Snide Reward Limit"
                                    data-toggle="tooltip"
                                    title="THIS IS ONLY RELEVANT IF YOU'RE SHUFFLING SNIDE REWARDS&#10;The max amount of blueprints that can be required to obtain a uncommon reward."
                                    min="0"
                                    max="40"
                                    value="40"
                            />
                        </div>
                    </div>
                </div>
            </div>
            <div class="d-flex" id="item_rando-category-container" data-items="{{ itemRando | tojsonarr | escape }}" data-count="5" data-predicate="item_rando_list_">
                {% for x in range(5) %}
                <div style="flex:1; max-width: 20%;">
                    <p class="select-title" style="margin-bottom: 0px;">
                        {% if x == 0 %}
                            Unshuffled
                        {% else %}
                            Pool {{ x }}
                        {% endif %}
                        <div id="item_rando_check_hint_{{ x }}">&nbsp;</div>
                    </p>
                    {% if x == 0 %}
                    <div class="text-start hide-if-ir-decouple">
                        <h6>Items</h6>
                    </div>
                    {% else %}
                    <div class="text-start hide-if-ir-decouple" style="opacity:0">
                        <h6>Items</h6>
                    </div>
                    {% endif %}
                    <ul id="item_rando_list_{{ x }}" name="item_rando_list_{{ x }}" class="sortablejs shared list-group bg-secondary-subtle border border-1 border-white mx-2" style="height: 200px; overflow-y: scroll">
                        {% if x == 0 %}
                            {% for option in itemRando %}
                                {% if not option.is_check %}
                                    {% if option.is_dummy %}
                                        <li class="list-group-item d-flex show-if-ir-decouple" value="{{ option.value }}" tooltip="{{ option.tooltip }}" check_count="{{ option.check_count }}" items_count="{{ option.item_count }}">
                                            <span class="fs-6 d-flex">
                                                <i class="fas fa-arrows-alt handle" style="height: 20px; width: 20px; padding-right: 5px" title="Drag to Move"></i>
                                                <i class="fas fa-clone clone-btn" style="height: 20px; width: 20px; padding-right: 5px" title="Drag to clone"></i>
                                            </span>
                                            <span class="flex-grow-1">
                                                {{ option.name }}
                                            </span>
                                        </li>
                                    {% else %}
                                        <li class="list-group-item d-flex" value="{{ option.value }}" tooltip="{{ option.tooltip }}" check_count="{{ option.check_count }}" items_count="{{ option.item_count }}">
                                            <span class="fs-6 d-flex">
                                                <i class="fas fa-arrows-alt handle" style="height: 20px; width: 20px; padding-right: 5px" title="Drag to Move"></i>
                                                <i class="fas fa-clone clone-btn" style="height: 20px; width: 20px; padding-right: 5px" title="Drag to Clone"></i>
                                            </span>
                                            <span class="flex-grow-1">
                                                {{ option.name }}
                                            </span>
                                        </li>
                                    {% endif %}
                                {% endif %}
                            {% endfor %}
                        {% endif %}
                    </ul>
                    {% if x == 0 %}
                    <div class="text-start mt-3 hide-if-ir-decouple">
                        <h6>Checks</h6>
                    </div>
                    {% else %}
                    <div class="text-start mt-3 hide-if-ir-decouple" style="opacity:0">
                        <h6>Checks</h6>
                    </div>
                    {% endif %}
                    <ul id="item_rando_list_{{ x + 5 }}" name="item_rando_list_{{ x + 5 }}" class="sortablejs sharedchecks list-group bg-secondary-subtle border border-1 border-white mx-2 hide-if-ir-decouple" style="height: 200px; overflow-y: scroll">
                        {% if x == 0 %}
                            {% for option in itemRando %}
                                {% if option.is_check %}
                                    <li class="list-group-item d-flex ischeck" value="{{ option.value }}" tooltip="{{ option.tooltip }}" check_count="{{ option.check_count }}" items_count="{{ option.item_count }}" tied_item="{{ option.tied }}">
                                        <span class="fs-6 d-flex">
                                            <i class="fas fa-arrows-alt handle" style="height: 20px; width: 20px; padding-right: 5px" title="Drag to Move"></i>
                                            <i class="fas fa-clone clone-btn" style="height: 20px; width: 20px; padding-right: 5px" title="Drag to Clone"></i>
                                        </span>
                                        <span class="flex-grow-1">
                                            {{ option.name }}
                                        </span>
                                    </li>
                                {% endif %}
                            {% endfor %}
                        {% endif %}
                    </ul>
                </div>
                {% endfor %}
            </div>
            <div class="flex-container mt-4">
                <button type="button" class="btn btn-secondary mx-3" style="flex: 1" id="item_rando_reset">Unshuffle All</button>
                <button type="button" class="btn btn-secondary mx-3" style="flex: 1" id="item_rando_shuffle_all">Shuffle All</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade"
     id="starting_moves_Modal"
     tabindex="-1"
     aria-labelledby="starting_moves_ModalLabel"
     aria-hidden="true">
    <div class="modal-dialog" style="max-width: 1250px;">
        <div class="modal-content modal-content-tall">
            <div class="modal-header">
                <h3 class="modal-title title" id="starting_moves_ModalLabel">CUSTOMIZE STARTING MOVES</h3>
                <button type="button"
                        class="btn-close"
                        data-bs-dismiss="modal"
                        aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <b>Place your items into a number of item pools, then choose how many of each pool's items you want given to you at the start of the seed.</b>
                <br/>
                <b>To move items, select them from any list and click the item pool you want them to be in.</b>
                <br/>
                <em>Use the presets at the bottom as quick actions.</em>
                <div class="flex-container" style="justify-content: space-around; margin-top: 15px;">
                    <div id="starting_moves_list_column_1" class="flex-column-container">
                        <b id="starting_moves_list_all_1" style="font-style: italic; color: green;">Start with All</b>
                        <b id="starting_moves_list_some_1" style="font-style: italic; color: orange;">Start with Some</b>
                        <b id="starting_moves_list_none_1" style="font-style: italic; color: red;">Start with None</b>
                        <button type="button" class="btn btn-secondary" id="starting_moves_list_mover_1">Pool 1</button>
                        <select id="starting_moves_list_1" name="starting_moves_list_1" class="starting_moves_list multi-select" multiple>
                            {% for item in custom_starting_moves %}
                                <option id="starting_move_{{item.value}}" class="starting_moves_option">{{item.name}}</option>
                            {% endfor %}
                        </select>
                        # Given:
                        <input min="0"
                                max="47"
                                display_name="Move Count"
                                name="starting_moves_list_count_1"
                                id="starting_moves_list_count_1"
                                class="form-control center-div move_count_button"
                                type="number"
                                data-toggle="tooltip"
                                title="Amount of moves given from this item pool."
                                default="0"
                                placeholder="0"
                                />
                    </div>
                    <div id="starting_moves_list_column_2" class="flex-column-container">
                        <b id="starting_moves_list_all_2" style="font-style: italic; color: green;">Start with All</b>
                        <b id="starting_moves_list_some_2" style="font-style: italic; color: orange;">Start with Some</b>
                        <b id="starting_moves_list_none_2" style="font-style: italic; color: red;">Start with None</b>
                        <button type="button" class="btn btn-secondary" id="starting_moves_list_mover_2">Pool 2</button>
                        <select id="starting_moves_list_2" name="starting_moves_list_2" class="starting_moves_list multi-select" multiple>
                        </select>
                        # Given:
                        <input min="0"
                                max="47"
                                display_name="Move Count"
                                name="starting_moves_list_count_2"
                                id="starting_moves_list_count_2"
                                class="form-control center-div move_count_button"
                                type="number"
                                data-toggle="tooltip"
                                title="Amount of moves given from this item pool."
                                default="0"
                                placeholder="0"
                                />
                    </div>
                    <div id="starting_moves_list_column_3" class="flex-column-container">
                        <b id="starting_moves_list_all_3" style="font-style: italic; color: green;">Start with All</b>
                        <b id="starting_moves_list_some_3" style="font-style: italic; color: orange;">Start with Some</b>
                        <b id="starting_moves_list_none_3" style="font-style: italic; color: red;">Start with None</b>
                        <button type="button" class="btn btn-secondary" id="starting_moves_list_mover_3">Pool 3</button>
                        <select id="starting_moves_list_3" name="starting_moves_list_3" class="starting_moves_list multi-select" multiple>
                        </select>
                        # Given:
                        <input min="0"
                                max="47"
                                display_name="Move Count"
                                name="starting_moves_list_count_3"
                                id="starting_moves_list_count_3"
                                class="form-control center-div move_count_button"
                                type="number"
                                data-toggle="tooltip"
                                title="Amount of moves given from this item pool."
                                default="0"
                                placeholder="0"
                                />
                    </div>
                    <div id="starting_moves_list_column_4" class="flex-column-container">
                        <b id="starting_moves_list_all_4" style="font-style: italic; color: green;">Start with All</b>
                        <b id="starting_moves_list_some_4" style="font-style: italic; color: orange;">Start with Some</b>
                        <b id="starting_moves_list_none_4" style="font-style: italic; color: red;">Start with None</b>
                        <button type="button" class="btn btn-secondary" id="starting_moves_list_mover_4">Pool 4</button>
                        <select id="starting_moves_list_4" name="starting_moves_list_4" class="starting_moves_list multi-select" multiple>
                        </select>
                        # Given:
                        <input min="0"
                                max="47"
                                display_name="Move Count"
                                name="starting_moves_list_count_4"
                                id="starting_moves_list_count_4"
                                class="form-control center-div move_count_button"
                                type="number"
                                data-toggle="tooltip"
                                title="Amount of moves given from this item pool."
                                default="0"
                                placeholder="0"
                                />
                    </div>
                    <div id="starting_moves_list_column_5" class="flex-column-container">
                        <b id="starting_moves_list_all_5" style="font-style: italic; color: green;">Start with All</b>
                        <b id="starting_moves_list_some_5" style="font-style: italic; color: orange;">Start with Some</b>
                        <b id="starting_moves_list_none_5" style="font-style: italic; color: red;">Start with None</b>
                        <button type="button" class="btn btn-secondary" id="starting_moves_list_mover_5">Pool 5</button>
                        <select id="starting_moves_list_5" name="starting_moves_list_5" class="starting_moves_list multi-select" multiple>
                        </select>
                        # Given:
                        <input min="0"
                                max="47"
                                display_name="Move Count"
                                name="starting_moves_list_count_5"
                                id="starting_moves_list_count_5"
                                class="form-control center-div move_count_button"
                                type="number"
                                data-toggle="tooltip"
                                title="Amount of moves given from this item pool."
                                default="0"
                                placeholder="0"
                                />
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="starting_moves_reset">No Item Start</button>
                <button type="button" class="btn btn-secondary" id="starting_moves_start_vanilla">Vanilla Start</button>
                <button type="button" class="btn btn-secondary" id="starting_moves_start_all">Start With All</button>
                <button type="button" class="btn btn-danger" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<script>
    const sort_container = document.getElementById("item_rando-category-container");
    const sort_sections_items = sort_container.getElementsByClassName("shared");
    const sort_sections_checks = sort_container.getElementsByClassName("sharedchecks");
    let offset = sort_sections_items.length;
    function makeSortable(el, groupName) {
        let dragFromCloneBtn = false; // flag to indicate next drag starts from clone button

        // detect mousedown/touchstart on clone buttons
        el.addEventListener('mousedown', e => {
            dragFromCloneBtn = !!e.target.closest('.clone-btn');
        });
        el.addEventListener('touchstart', e => {
            dragFromCloneBtn = !!e.target.closest('.clone-btn');
        });

        new Sortable(el, {
            group: {
                name: groupName,
                pull: (t, f, d, e) => {
                    return dragFromCloneBtn ? 'clone' : true;
                }, // always clone; emulate move if needed
                put: [groupName]
            },
            handle: '.handle, .clone-btn', // only handle moves normally
            animation: 150,
            fallbackTolerance: 3,
            sort: false,

            onStart(evt) {
                // set a dataset flag on the dragged item based on pre-recorded info
                evt.item.dataset.cloneMode = dragFromCloneBtn ? 'true' : 'false';
            },

            onAdd(evt) {
                const item = evt.item;
                const to = evt.to;
                const cloneMode = item.dataset.cloneMode === 'true';

                if (!cloneMode) {
                    const from = evt.from;
                    if (from && from.contains(item)) {
                    from.removeChild(item); // emulate move
                    }
                }

                // remove duplicates in the destination based on value attribute
                const value = item.getAttribute('value');
                if (value) {
                    const duplicates = Array.from(to.querySelectorAll('li')).filter(
                        li => li !== item && li.getAttribute('value') === value
                    );
                    duplicates.forEach(dup => dup.remove());
                }

                delete item.dataset.cloneMode;

                const changeEvent = new Event('change', { bubbles: true, cancelable: false });
                evt.to.dispatchEvent(changeEvent);
                updateCheckItemCounter(evt.to.parentElement.parentElement);
            }
        });
    }
    for (let i = 0; i < offset; i++) {
        makeSortable(sort_sections_items[i], 'shared');
        makeSortable(sort_sections_checks[i], 'sharedchecks');
    }

    function isNumeric(str) {
        if (typeof str != "string") return false // we only process strings!  
        return !isNaN(str) && // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...
                !isNaN(parseFloat(str)) // ...and ensure strings of whitespace fail
    }

    const item_count_mapping = {
        "medal": "total_medals",
        "banana": "total_gbs",
        "fairy": "total_fairies",
        "pearl": "total_pearls",
        "crown": "total_crowns",
        "rainbowcoin": "total_rainbow_coins",
    }
    function isShuffled(item_or_check) {
        for (let x = 1; x < 5; x++) {
            for (let y = 0; y < 2; y++) {
                const idx = (y * 5) + x;
                const ul = document.getElementById(`item_rando_list_${idx}`);
                const ils = ul.getElementsByTagName("li");
                for (let i = 0; i < ils.length; i++) {
                    if (ils[i].getAttribute("value") == item_or_check) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function getBananaReduction() {
        const reduction_data = {
            "blueprintbanana": 40,
            "racebanana": 11,
            "gauntletbanana": 16,
        };
        let total = 0;
        Object.keys(reduction_data).forEach(item_type => {
            if (!isShuffled(item_type)) {
                total += reduction_data[item_type];
            }
        })
        return total;
    }

    function getItemChange(item, original_value) {
        if (Object.keys(item_count_mapping).includes(item)) {
            const ic_value = parseInt(document.getElementById(item_count_mapping[item]).value)
            if (item == "banana") {
                return Math.max(ic_value - getBananaReduction(), 0);
            }
            return ic_value;
        }
        return original_value;
    }

    function getCheckChange(item, original_value) {
        if ((item === "shop") && document.getElementById("smaller_shops").checked) {
            return 60
        } else if ((["halfmedal", "medal_checks"].includes(item)) && islesCBs()) {
            return 40
        }
        return original_value;
    }

    function islesCBs() {
        return document.querySelector("#cb_rando_list_selected option[value='DKIsles']").selected && document.getElementById("cb_rando_enabled").checked;
    }

    function getTiedCheckCount(value) {
        const data_items_json = document.getElementById("item_rando-category-container").getAttribute("data-items");
        const data_items = JSON.parse(data_items_json);
        const tied_checks = data_items.filter(k => (k.is_check && k.tied == value) || (k.is_dummy && k.value == value));
        let count = 0;
        let latest_value = null;
        tied_checks.forEach(k => {
            count += getCheckChange(k.value, k.check_count);
            latest_value = k.value;
        });
        return {
            "size": count,
            "name": latest_value,
        }
    }

    function populateCheck(outputs, name, size, index) {
        if (index > 0) {
            if (!Object.keys(outputs).includes(name)) {
                outputs[name] = {
                    size: size,
                    pools: [index - 1]
                }
            } else {
                outputs[name].pools.push(index - 1)
            }
        }
        return outputs;
    }

    function updateCheckItemCounter(ctr) {
        const name = ctr.getAttribute("id").split("-category-container")[0];
        const sort_sections_items = sort_container.getElementsByClassName("shared");
        const sort_sections_checks = sort_container.getElementsByClassName("sharedchecks");
        const decoupled = document.getElementById("decouple_item_rando").checked;
        let is_valid_item_spread = true;
        
        let item_shuffle_cache = {};
        let item_shuffle_tied = {};
        let offset = sort_sections_items.length;
        let inputs = {};
        let outputs = {};
        let pools = {};
        let poolstatus = {};
        for (let index = 0; index < offset; index++) {
            let local_check_count = 0;
            let local_item_count = 0;
            let parsed_options = 0;
            for (let j = 0; j < 2; j++) {
                let options;
                if (j == 0) {
                    options = sort_sections_items[index].getElementsByTagName("li");
                } else if (j == 1) {
                    options = sort_sections_checks[index].getElementsByTagName("li");
                }
                if (!decoupled && (j == 1)) {
                    continue;
                }
                for (let option of options) {
                    const check_count_raw = option.getAttribute("check_count");
                    const item_count_raw = option.getAttribute("items_count");
                    const tied_item_raw = option.getAttribute("tied_item");
                    const opt_value = option.getAttribute("value");
                    item_shuffle_cache[opt_value] = index;
                    let parsed = false;
                    if (tied_item_raw) {
                        item_shuffle_tied[opt_value] = tied_item_raw;
                    }
                    if (!decoupled) {
                        let data = getTiedCheckCount(opt_value);
                        if (data.size > 0) {
                            outputs = populateCheck(outputs, data.name, data.size, index);
                        }
                        parsed = true;
                    } else if (j == 1) {
                        if (isNumeric(check_count_raw)) {
                            let size = getCheckChange(opt_value, parseInt(check_count_raw));
                            if (size > 0) {
                                outputs = populateCheck(outputs, opt_value, size, index);
                            }
                            parsed = true;
                        }
                    }
                    if (isNumeric(item_count_raw)) {
                        let size = getItemChange(opt_value, parseInt(item_count_raw));
                        if (size > 0) {
                            inputs = populateCheck(inputs, opt_value, size, index);
                        }
                        parsed = true;
                    }
                    if (parsed) {
                        parsed_options++;
                    }
                }
            }
            if (index > 0) {
                pools[index] = [];
                poolstatus[index] = true;
            }
            /*
            if (index > 0) {
                let inner_text = "";
                if (parsed_options > 0) {
                    inner_text = `Checks: ${local_check_count} | Items: ${local_item_count}`;
                }
                if (local_item_count > local_check_count) {
                    is_valid_item_spread = false;
                }
                const check_hint_el = document.getElementById(`${name}_check_hint_${index}`);
                check_hint_el.title = "";
                let text_color = "DarkCyan";
                if (local_item_count > local_check_count) {
                    // Too many items for the amount of checks
                    text_color = "red";
                } else if (local_item_count == local_check_count) {
                    text_color = "DarkOrange";
                    check_hint_el.title = "This pool might have some trouble generating.";
                } else {
                    text_color = "green";
                }
                check_hint_el.innerHTML = inner_text;
                check_hint_el.style.color = text_color;
            }
            */
        }
        // Calculations
        function checkDistribution(liquids, buckets, debug=false) {
            if (debug) console.clear();
            if (debug) console.log("Checking distribution");
            const pool_count = 4;
            let pool_valid = [];
            let pool_verified = [];
            let pool_liquids = [];
            let pool_buckets = [];
            for (let x = 0; x < pool_count; x++) {
                pool_valid.push(true);
                pool_verified.push(false);
                pool_liquids.push(0);
                pool_buckets.push(0);
            }
            let lq_copy = liquids.slice();
            let bk_copy = buckets.slice();
            let iter_count = 100;
            let ran_rules = [];
            while (true) {
                /*
                    Rule 1:
                    Any pools which only have checks or only have items should get filtered out
                    if their non-filtered version has more than 0 items.
                    This can only be ran once.
                */
                if (!ran_rules.includes(1)) {
                    let has_liquids = [];
                    let has_buckets = [];
                    for (let x = 0; x < pool_count; x++) {
                        has_liquids.push(false);
                        has_buckets.push(false);
                    }
                    lq_copy.forEach(lq => {
                        lq.pools.forEach(pl => {
                            has_liquids[pl] = true;
                        })
                    });
                    bk_copy.forEach(bk => {
                        bk.pools.forEach(pl => {
                            has_buckets[pl] = true;
                        })
                    });
                    let pools_to_filter = [];
                    for (let x = 0; x < pool_count; x++) {
                        if (!has_buckets[x] || !has_liquids[x]) {
                            pools_to_filter.push(x);
                        }
                    }
                    pools_to_filter.forEach(pl => {
                        lq_copy.forEach(lq => {
                            if (lq.pools.includes(pl)) {
                                let filtered_version = lq.pools.filter(i => !pools_to_filter.includes(i));
                                if (filtered_version.length > 0) {
                                    if (debug) console.log(`Filtering out ${lq.pools.length - filtered_version.length} values from pool ${pl}`);
                                    lq.pools = filtered_version.slice();
                                } else {
                                    // This is the only instance of this item, thus making this pool invalid
                                    pool_valid[pl] = false;
                                    pool_verified[pl] = true;
                                }
                            }
                        });
                        bk_copy.forEach(bk => {
                            if (bk.pools.includes(pl)) {
                                let filtered_version = bk.pools.filter(i => !pools_to_filter.includes(i));
                                if (filtered_version.length > 0) {
                                    if (debug) console.log(`Filtering out ${bk.pools.length - filtered_version.length} values from pool ${pl}`);
                                    bk.pools = filtered_version.slice();
                                } else {
                                    // This is the only instance of this item, thus making this pool invalid
                                    pool_valid[pl] = false;
                                    pool_verified[pl] = true;
                                }
                            }
                        });
                    })
                    ran_rules.push(1);
                }
                /*
                    Rule 2:
                    Any completely empty pools should add all of their items/checks in them
                    Any pools with greater amounts of items than checks gets flagged as invalid.
                */
                let found_lq = [];
                let found_bk = [];
                for (let x = 0; x < pool_count; x++) {
                    found_lq.push(false);
                    found_bk.push(false);
                }
                lq_copy.forEach(lq => {
                    lq.pools.forEach(pl => {
                        found_lq[pl] = true;
                    })
                })
                bk_copy.forEach(bk => {
                    bk.pools.forEach(pl => {
                        found_bk[pl] = true;
                    })
                })
                for (let x = 0; x < pool_count; x++) {
                    if (!found_lq[x] && !found_bk[x]) {
                        if (pool_buckets[x] < pool_liquids[x]) {
                            if (debug) console.log(`Too many items for pool ${x + 1}: ${pool_liquids[x]} vs ${pool_buckets[x]}`);
                            pool_valid[x] = false;
                            pool_verified[x] = true;
                        }
                    }
                }
                /*
                    Rule 3:
                    Any items/checks which are only part of 1 pool should get filtered out and applied to a guaranteed liq/buck total
                */
                let temp_lq = [];
                lq_copy.forEach(lq => {
                    if (lq.pools.length == 1) {
                        pool_liquids[lq.pools[0]] += lq.size;
                    } else {
                        temp_lq.push(lq);
                    } 
                });
                lq_copy = temp_lq.slice();
                let temp_bk = [];
                bk_copy.forEach(bk => {
                    if (bk.pools.length == 1) {
                        pool_buckets[bk.pools[0]] += bk.size;
                    } else {
                        temp_bk.push(bk);
                    } 
                });
                bk_copy = temp_bk.slice();
                /*
                    Rule 4:
                    For all remaining buckets, check the pools which need the checks the most
                */
                let bucket_deficit = pool_liquids.map((v, i) => v - pool_buckets[i]);
                temp_bk = [];
                bk_copy.forEach(bk => {
                    let remove = false;
                    let bucket_needed = null;
                    let bucket_deficit_needed = null;
                    bk.pools.forEach(pl => {
                        if (bucket_deficit[pl] >= 0) {
                            if (bucket_needed === null || bucket_deficit[pl] > bucket_deficit_needed) {
                                bucket_needed = pl;
                                bucket_deficit_needed = bucket_deficit[pl];
                            }
                        }
                    })
                    if (bucket_needed !== null) {
                        let bucket_capacity_supplied = Math.min(bucket_deficit_needed, bk.size);
                        bk.size -= bucket_capacity_supplied;
                        pool_buckets[bucket_needed] += bucket_capacity_supplied;
                        bk.pools = bk.pools.filter(i => i !== bucket_needed);
                        if (bk.size < 1) {
                            remove = true;
                        }
                    }
                    if (!remove) {
                        temp_bk.push(bk);
                    }
                })
                bk_copy = temp_bk.slice();
                /*
                    Rule 5:
                    For all remaining liquids, check the pools which have the smallest bucket gap
                */
                let bucket_surplus = pool_buckets.map((v, i) => v - pool_liquids[i]);
                temp_lq = [];
                lq_copy.forEach(lq => {
                    let remove = false;
                    let bucket_needed = null;
                    let bucket_surplus_needed = null;
                    lq.pools.forEach(pl => {
                        if (bucket_surplus[pl] >= 0) {
                            if (bucket_needed === null || bucket_surplus[pl] < bucket_surplus_needed) {
                                bucket_needed = pl;
                                bucket_surplus_needed = bucket_surplus[pl];
                            }
                        }
                    })
                    if (bucket_needed !== null) {
                        let liquid_supplied = Math.min(bucket_surplus_needed, lq.size);
                        lq.size -= liquid_supplied;
                        pool_liquids[bucket_needed] += liquid_supplied;
                        lq.pools = lq.pools.filter(i => i !== bucket_needed);
                        if (lq.size < 1) {
                            remove = true;
                        }
                    }
                    if (!remove) {
                        temp_lq.push(lq);
                    }
                })
                lq_copy = temp_lq.slice();
                // Termination checks
                let terminate = lq_copy.length == 0 && bk_copy.length == 0;
                if (terminate) {
                    pool_valid = pool_liquids.map((v, i) => (pool_valid[i] & v <= pool_buckets[i]) !== 0);
                    pool_verified = [true, true, true, true];
                }
                let terminate_verified = true;
                for (let x = 0; x < pool_count; x++) {
                    if (pool_valid[x]) {
                        terminate = false;
                    }
                    if (!pool_verified[x]) {
                        terminate_verified = false;
                    }
                }
                if (terminate || terminate_verified) {
                    break;
                }
                iter_count--;
                if (iter_count < 1) {
                    break;
                }
            }
            if (debug) {
                let data = {
                    remaining_liquids: lq_copy,
                    remaining_buckets: bk_copy,
                    verified: pool_verified,
                    valid: pool_valid,
                    liquid_sum: pool_liquids,
                    bucket_sum: pool_buckets,
                }
            }
            return {
                valid: pool_valid,
                item_counts: pool_liquids,
                check_counts: pool_buckets,
            }
        }

        const result = checkDistribution(Object.values(inputs), Object.values(outputs), false);
        is_valid_item_spread = true;
        for (let x = 0; x < 4; x++) {
            const node = document.getElementById(`item_rando_check_hint_${x + 1}`);
            node.innerText = `Items: ${result.item_counts[x]} | Checks: ${result.check_counts[x]}`;
            is_valid_item_spread &= result.valid[x];
            if (result.valid[x]) {
                node.style.color = "green";
                node.title = "Pool is valid";
            } else {
                node.style.color = "red";
                node.title = "Pool is invalid due to too many items/too few checks";
            }
        }

        let is_valid_item_shuffle = true;
        Object.keys(item_shuffle_tied).forEach(key => {
            const val = item_shuffle_tied[key];
            let valid_check = true;
            if ((val == "banana") && (key != "banana_checks")) {
                valid_check = false;
            }
            if (valid_check) {
                const key_slot = item_shuffle_cache[key];
                const val_slot = item_shuffle_cache[val];
                if (key_slot != val_slot) {
                    if ((key_slot == 0) || (val_slot == 0)) {
                        // Key or val is in slot 0, but not both
                        is_valid_item_shuffle = false;
                    }
                }
            }
        });
        document.getElementById("rule-item-count").style.color = is_valid_item_spread ? "white" : "red";
        document.getElementById("rule-item-shuffle").style.color = is_valid_item_shuffle ? "white" : "red";
    }


    function setAllToColumn(name, index) {
        const container = document.getElementById(`${name}-category-container`);
        const sort_sections_items = sort_container.getElementsByClassName("shared");
        const sort_sections_checks = sort_container.getElementsByClassName("sharedchecks");
        const offset = sort_sections_items.length;
        let total_html_items = "";
        let total_html_checks = "";
        let total_items_values = [];
        let total_checks_values = [];
        for (let i = 0; i < offset; i++) {
            const items = sort_sections_items[i].getElementsByTagName("li");
            const checks = sort_sections_checks[i].getElementsByTagName("li");
            for (let k = 0; k < items.length; k++) {
                const item_value = items[k].getAttribute("value");
                if (!total_items_values.includes(item_value)) {
                    total_items_values.push(item_value);
                    total_html_items += items[k].outerHTML;
                }
            }
            for (let k = 0; k < checks.length; k++) {
                const check_value = checks[k].getAttribute("value");
                if (!total_checks_values.includes(check_value)) {
                    total_checks_values.push(check_value);
                    total_html_checks += checks[k].outerHTML;
                }
            }
        }
        for (let i = 0; i < offset; i++) {
            if (i == index) {
                sort_sections_items[index].innerHTML = total_html_items;
                sort_sections_checks[index].innerHTML = total_html_checks;
            } else {
                sort_sections_items[i].innerHTML = "";
                sort_sections_checks[i].innerHTML = "";
            }
            const event = new Event("change", { bubbles: true, cancelable: false });
            sort_sections_items[i].dispatchEvent(event);
            sort_sections_checks[i].dispatchEvent(event);
        }
        updateCheckItemCounter(container);
    }

    document.getElementById("decouple_item_rando").addEventListener("click", () => {
        const container = document.getElementById("item_rando-category-container");
        updateCheckItemCounter(container);
    });

    document.getElementById("item_rando_reset").addEventListener("click", (e) => {setAllToColumn("item_rando", 0)});
    document.getElementById("item_rando_shuffle_all").addEventListener("click", (e) => {setAllToColumn("item_rando", 1)});
</script>
<script>
    $(function() {
        $('[data-toggle="tooltip"]').tooltip({
            trigger: 'hover'
        });
    });
</script>